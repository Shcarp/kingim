package serv

import (
	"bytes"
	"github.com/golang/protobuf/proto"
	"kingim"
	"kingim/container"
	"kingim/logger"
	"kingim/wire"
	"kingim/wire/pkt"
	"strings"
	"time"
)

var log = logger.WithFields(logger.Fields{
	"service" : wire.SNChat,
	"pkg" : "serv",
})

type ServHandler struct {
	r *kingim.Router
	cache kingim.SessionStorage
	dispather *ServerDispather
}

type ServerDispather struct {

}

func NewServHandler(router *kingim.Router, cache kingim.SessionStorage) *ServHandler {
	return &ServHandler{
		r: router,
		cache: cache,
		dispather: &ServerDispather{},
	}
}

func (h*ServHandler) Accept(conn kingim.Conn, timeout time.Duration) (string,error) {
	log.Infoln("enter")

	_ = conn.SetReadDeadline(time.Now().Add(timeout))
	frame, err := conn.ReadFrame()
	if err != nil {
		return "", err
	}
	var req pkt.InnerHandshakeReq
	_ = proto.Unmarshal(frame.GetPayload(),&req)
	log.Info("Accept -- ", req.ServiceId)
	return req.ServiceId,nil
}

func (h*ServHandler) Receive(ag kingim.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)
	packet, err := pkt.MustReadLogicPkt(buf)  // 必须是LogicPkt
	if err != nil {
		return
	}
	var session *pkt.Session
	// 如果是登录则生成一个Session //否则在cache中读取一个
	if packet.Command == wire.CommandLoginSignIn {
		server ,_ := packet.GetMeta(wire.MetaDestServer)
		session = &pkt.Session{
			ChannelId: packet.ChannelId,  // 全局唯一ID
			GateId: server.(string),
			Tags: []string{"AutoGenerated"},
		}
	} else {
		session, err = h.cache.Get(packet.ChannelId)
		if err == kingim.ErrSessionNil {
			_ = RespErr(ag, packet, pkt.Status_SessionNotFound)
			return
		}else {
			_ = RespErr(ag, packet, pkt.Status_SystemException)
			return
		}
	}
	logger.Debugf("recv a message from %s %s", session, &packet.Header)
	err = h.r.Serve(packet, h.dispather, h.cache, session)
	if err != nil {
		log.Warn(err)
	}
}

func RespErr(ag kingim.Agent, p *pkt.LogicPkt, status pkt.Status) error {
	packet := pkt.NewFrom(&p.Header)
	packet.Status = status
	packet.Flag = pkt.Flag_Response
	return ag.Push(pkt.Marshal(packet))
}
// 因为那边可能传过来数组    // ctx 中的push就是从这里传入
func (s*ServerDispather) Push(gateway string, channels []string, p *pkt.LogicPkt) error {
	p.AddStringMeta(wire.MetaDestChannels, strings.Join(channels, ","))   // 将传入的需要发送的数组拼接为字符串形式
	return container.Push(gateway ,p)    // 调用容器方法
}

func (h*ServHandler) Disconnect(id string) error {
	logger.Warnf("close event of %s", id)
	return nil
}
